// This file was generated by Peginator v0.6.0 built at 1695482556
// CRC-32/ISO-HDLC of the grammar file: 3a135737
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct File {
    pub statements: Vec<Statement>,
}
#[derive(Debug, Clone)]
pub struct Statement {
    pub r#fn: Option<FunctionDef>,
    pub var: Option<VariableDef>,
    pub expr: Option<Expression>,
}
#[derive(Debug, Clone)]
pub struct FunctionDef {
    pub name: Ident,
    pub param_list: ParamList,
    pub return_value: Option<Type>,
}
#[derive(Debug, Clone)]
pub struct ParamList {
    pub self_param: Option<SelfParam>,
    pub params: Vec<Param>,
}
#[derive(Debug, Clone)]
pub struct Param {
    pub name: Ident,
    pub typ: Type,
}
#[derive(Debug, Clone)]
pub struct SelfParam {
    pub ref_type: Option<ReferenceMarker>,
}
#[derive(Debug, Clone)]
pub struct Type {
    pub ref_type: Option<ReferenceMarker>,
    pub typename: Ident,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum ReferenceMarker {
    ImmutableReference(ImmutableReference),
    MutableReference(MutableReference),
}
#[derive(Debug, Clone)]
pub struct ImmutableReference;
#[derive(Debug, Clone)]
pub struct MutableReference;
#[derive(Debug, Clone)]
pub struct VariableDef {
    pub name: Ident,
    pub typ: Type,
    pub expr: Expression,
}
#[derive(Debug, Clone)]
pub struct Expression {
    pub expr: BinaryExpression,
}
#[derive(Debug, Clone)]
pub struct BinaryExpression {
    pub left: UnaryExpression,
    pub op: BinaryOperator,
    pub right: UnaryExpression,
}
#[derive(Debug, Clone)]
pub struct UnaryExpression {
    pub op: UnaryOperator,
    pub expr: PrimaryExpression,
}
#[derive(Debug, Clone)]
pub struct PrimaryExpression {
    pub expr: PrimaryExpression_expr,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum PrimaryExpression_expr {
    FunctionCall(FunctionCall),
    Literal(Literal),
    ParenExpression(ParenExpression),
    Variable(Variable),
}
#[derive(Debug, Clone)]
pub struct ParenExpression {
    pub expr: Vec<Expression>,
}
#[derive(Debug, Clone)]
pub struct Variable {
    pub name: Ident,
}
#[derive(Debug, Clone)]
pub struct FunctionCall {
    pub name: Ident,
    pub args: ArgumentList,
}
#[derive(Debug, Clone)]
pub struct ArgumentList {
    pub arg: Vec<Expression>,
}
#[derive(Debug, Clone)]
pub struct Literal {
    pub int: Option<Integer>,
    pub float: Option<Float>,
}
#[derive(Debug, Clone)]
pub struct Integer;
#[derive(Debug, Clone)]
pub struct Float;
#[derive(Debug, Clone)]
pub struct Digit;
#[derive(Debug, Clone)]
pub struct BinaryOperator;
#[derive(Debug, Clone)]
pub struct UnaryOperator;
pub type Ident = String;
impl peginator_generated::PegParserAdvanced<()> for File {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_defined: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_File(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_defined,
            ),
        )?
        .result)
    }
}
#[allow(
    non_snake_case,
    unused_variables,
    unused_imports,
    unused_mut,
    dead_code
)]
mod peginator_generated {
    use super::*;
    use peginator::*;
    pub use peginator::{
        IndentedTracer, ParseError, ParseGlobal, ParseSettings, ParseState, ParseTracer, PegParser,
        PegParserAdvanced, PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod File_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            let mut statements: Vec<Statement> = Vec::new();
            loop {
                match parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_Statement(state, &mut *global))
                    .map_inner(|result| vec![result])
                {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        statements.extend(__result);
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk {
                result: statements,
                state,
            })
        }
        pub type Parsed = Vec<Statement>;
    }
    #[inline]
    pub(super) fn parse_File<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, File> {
        global.tracer.print_trace_start(&state, "File");
        let result = {
            let result = File_impl::parse(state, global)?.map(|r| super::File { statements: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Statement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_FunctionDef(state, &mut *global))
                        .map_inner(Some)
                        .map_inner(|r| Parsed {
                            r#fn: r,
                            var: None,
                            expr: None,
                        })
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_VariableDef(state, &mut *global))
                        .map_inner(Some)
                        .map_inner(|r| Parsed {
                            r#fn: None,
                            var: r,
                            expr: None,
                        })
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Expression(state, &mut *global))
                        .map_inner(Some)
                        .map_inner(|r| Parsed {
                            r#fn: None,
                            var: None,
                            expr: r,
                        })
                })
                .end()
        }
        pub struct Parsed {
            pub r#fn: Option<FunctionDef>,
            pub var: Option<VariableDef>,
            pub expr: Option<Expression>,
        }
    }
    #[inline]
    pub(super) fn parse_Statement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Statement> {
        global.tracer.print_trace_start(&state, "Statement");
        let result = {
            let result = Statement_impl::parse(state, global)?.map(|r| super::Statement {
                r#fn: r.r#fn,
                var: r.var,
                expr: r.expr,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod FunctionDef_impl {
        use super::*;
        mod part_5 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "->"))
                        .discard_result()?;
                    let ParseOk {
                        result: return_value,
                        state,
                    } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Type(state, &mut *global))
                        .map_inner(Some)?;
                    Ok(ParseOk {
                        result: return_value,
                        state,
                    })
                }
                pub type Parsed = Option<Type>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global).or_else(|err| {
                    Ok(ParseOk {
                        result: Default::default(),
                        state: state.record_error(err),
                    })
                })
            }
            pub type Parsed = Option<Type>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "fn"))
                .discard_result()?;
            let ParseOk {
                result: name,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Ident(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk {
                result: param_list,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ParamList(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            let ParseOk {
                result: return_value,
                state,
            } = part_5::parse(state, global)?;
            Ok(ParseOk {
                result: Parsed {
                    name,
                    param_list,
                    return_value,
                },
                state,
            })
        }
        pub struct Parsed {
            pub name: Ident,
            pub param_list: ParamList,
            pub return_value: Option<Type>,
        }
    }
    #[inline]
    pub(super) fn parse_FunctionDef<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, FunctionDef> {
        global.tracer.print_trace_start(&state, "FunctionDef");
        let result = {
            let result = FunctionDef_impl::parse(state, global)?.map(|r| super::FunctionDef {
                name: r.name,
                param_list: r.param_list,
                return_value: r.return_value,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ParamList_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk {
                            result: mut params,
                            state,
                        } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_Param(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk {
                            result: params,
                            state,
                        })
                    }
                    pub type Parsed = Vec<Param>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut params: Vec<Param> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk {
                                result: __result,
                                state: new_state,
                                ..
                            }) => {
                                params.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk {
                        result: params,
                        state,
                    })
                }
                pub type Parsed = Vec<Param>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk {
                    result: self_param,
                    state,
                } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_SelfParam(state, &mut *global))
                    .map_inner(Some)?;
                let ParseOk {
                    result: mut params,
                    state,
                } = part_1::parse(state, global)?;
                Ok(ParseOk {
                    result: Parsed { self_param, params },
                    state,
                })
            }
            pub struct Parsed {
                pub self_param: Option<SelfParam>,
                pub params: Vec<Param>,
            }
        }
        mod choice_1 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk {
                            result: mut params,
                            state,
                        } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_Param(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk {
                            result: params,
                            state,
                        })
                    }
                    pub type Parsed = Vec<Param>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut params: Vec<Param> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk {
                                result: __result,
                                state: new_state,
                                ..
                            }) => {
                                params.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk {
                        result: params,
                        state,
                    })
                }
                pub type Parsed = Vec<Param>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk {
                    result: mut params,
                    state,
                } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_Param(state, &mut *global))
                    .map_inner(|result| vec![result])?;
                let ParseOk {
                    result: extend_params_with,
                    state,
                } = part_1::parse(state, global)?;
                params.extend(extend_params_with);
                Ok(ParseOk {
                    result: params,
                    state,
                })
            }
            pub type Parsed = Vec<Param>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    choice_0::parse(state, global).map_inner(|r| Parsed {
                        self_param: r.self_param,
                        params: r.params,
                    })
                })
                .choice(|state| {
                    choice_1::parse(state, global).map_inner(|r| Parsed {
                        self_param: None,
                        params: r,
                    })
                })
                .choice(|state| {
                    Ok(ParseOk { result: (), state }).map_inner(|r| Parsed {
                        self_param: None,
                        params: Vec::new(),
                    })
                })
                .end()
        }
        pub struct Parsed {
            pub self_param: Option<SelfParam>,
            pub params: Vec<Param>,
        }
    }
    #[inline]
    pub(super) fn parse_ParamList<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ParamList> {
        global.tracer.print_trace_start(&state, "ParamList");
        let result = {
            let result = ParamList_impl::parse(state, global)?.map(|r| super::ParamList {
                self_param: r.self_param,
                params: r.params,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Param_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: name,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Ident(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                .discard_result()?;
            let ParseOk { result: typ, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Type(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed { name, typ },
                state,
            })
        }
        pub struct Parsed {
            pub name: Ident,
            pub typ: Type,
        }
    }
    #[inline]
    pub(super) fn parse_Param<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Param> {
        global.tracer.print_trace_start(&state, "Param");
        let result = {
            let result = Param_impl::parse(state, global)?.map(|r| super::Param {
                name: r.name,
                typ: r.typ,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SelfParam_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: ref_type,
                state,
            } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ReferenceMarker(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| {
                    Ok(ParseOk {
                        result: Default::default(),
                        state: state.record_error(err),
                    })
                })?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "self"))
                .discard_result()?;
            Ok(ParseOk {
                result: ref_type,
                state,
            })
        }
        pub type Parsed = Option<ReferenceMarker>;
    }
    #[inline]
    pub(super) fn parse_SelfParam<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SelfParam> {
        global.tracer.print_trace_start(&state, "SelfParam");
        let result = {
            let result =
                SelfParam_impl::parse(state, global)?.map(|r| super::SelfParam { ref_type: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Type_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: ref_type,
                state,
            } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ReferenceMarker(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| {
                    Ok(ParseOk {
                        result: Default::default(),
                        state: state.record_error(err),
                    })
                })?;
            let ParseOk {
                result: typename,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Ident(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed { ref_type, typename },
                state,
            })
        }
        pub struct Parsed {
            pub ref_type: Option<ReferenceMarker>,
            pub typename: Ident,
        }
    }
    #[inline]
    pub(super) fn parse_Type<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Type> {
        global.tracer.print_trace_start(&state, "Type");
        let result = {
            let result = Type_impl::parse(state, global)?.map(|r| super::Type {
                ref_type: r.ref_type,
                typename: r.typename,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ReferenceMarker_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_MutableReference(state, global))
                        .map_inner(Parsed__override::MutableReference)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ImmutableReference(state, global))
                        .map_inner(Parsed__override::ImmutableReference)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::ReferenceMarker as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_ReferenceMarker<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ReferenceMarker> {
        global.tracer.print_trace_start(&state, "ReferenceMarker");
        let result = {
            let result = ReferenceMarker_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ImmutableReference_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '&'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_ImmutableReference<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ImmutableReference> {
        global
            .tracer
            .print_trace_start(&state, "ImmutableReference");
        let result = {
            let result = ImmutableReference_impl::parse(state, global)?
                .map(|r| super::ImmutableReference {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod MutableReference_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '&'))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "mut"))
                .discard_result()?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_MutableReference<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, MutableReference> {
        global.tracer.print_trace_start(&state, "MutableReference");
        let result = {
            let result =
                MutableReference_impl::parse(state, global)?.map(|r| super::MutableReference {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod VariableDef_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "let"))
                .discard_result()?;
            let ParseOk {
                result: name,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Ident(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                .discard_result()?;
            let ParseOk { result: typ, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Type(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                .discard_result()?;
            let ParseOk {
                result: expr,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Expression(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed { name, typ, expr },
                state,
            })
        }
        pub struct Parsed {
            pub name: Ident,
            pub typ: Type,
            pub expr: Expression,
        }
    }
    #[inline]
    pub(super) fn parse_VariableDef<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, VariableDef> {
        global.tracer.print_trace_start(&state, "VariableDef");
        let result = {
            let result = VariableDef_impl::parse(state, global)?.map(|r| super::VariableDef {
                name: r.name,
                typ: r.typ,
                expr: r.expr,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Expression_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_BinaryExpression(state, &mut *global))
        }
        pub type Parsed = BinaryExpression;
    }
    #[inline]
    pub(super) fn parse_Expression<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Expression> {
        global.tracer.print_trace_start(&state, "Expression");
        let result = {
            let result =
                Expression_impl::parse(state, global)?.map(|r| super::Expression { expr: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod BinaryExpression_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: left,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_UnaryExpression(state, &mut *global))?;
            let ParseOk { result: op, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_BinaryOperator(state, &mut *global))?;
            let ParseOk {
                result: right,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_UnaryExpression(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed { left, op, right },
                state,
            })
        }
        pub struct Parsed {
            pub left: UnaryExpression,
            pub op: BinaryOperator,
            pub right: UnaryExpression,
        }
    }
    #[inline]
    pub(super) fn parse_BinaryExpression<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, BinaryExpression> {
        global.tracer.print_trace_start(&state, "BinaryExpression");
        let result = {
            let result =
                BinaryExpression_impl::parse(state, global)?.map(|r| super::BinaryExpression {
                    left: r.left,
                    op: r.op,
                    right: r.right,
                });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod UnaryExpression_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: op, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_UnaryOperator(state, &mut *global))?;
            let ParseOk {
                result: expr,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PrimaryExpression(state, &mut *global))?;
            Ok(ParseOk {
                result: Parsed { op, expr },
                state,
            })
        }
        pub struct Parsed {
            pub op: UnaryOperator,
            pub expr: PrimaryExpression,
        }
    }
    #[inline]
    pub(super) fn parse_UnaryExpression<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, UnaryExpression> {
        global.tracer.print_trace_start(&state, "UnaryExpression");
        let result = {
            let result =
                UnaryExpression_impl::parse(state, global)?.map(|r| super::UnaryExpression {
                    op: r.op,
                    expr: r.expr,
                });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod PrimaryExpression_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Literal(state, &mut *global))
                        .map_inner(Parsed_expr::Literal)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Variable(state, &mut *global))
                        .map_inner(Parsed_expr::Variable)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_FunctionCall(state, &mut *global))
                        .map_inner(Parsed_expr::FunctionCall)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| {
                            parse_ParenExpression(state, &mut *global)
                        })
                        .map_inner(Parsed_expr::ParenExpression)
                })
                .end()
        }
        pub type Parsed = Parsed_expr;
        use super::PrimaryExpression_expr as Parsed_expr;
    }
    #[inline]
    pub(super) fn parse_PrimaryExpression<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PrimaryExpression> {
        global.tracer.print_trace_start(&state, "PrimaryExpression");
        let result = {
            let result = PrimaryExpression_impl::parse(state, global)?
                .map(|r| super::PrimaryExpression { expr: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ParenExpression_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut expr: Vec<Expression> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Expression(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            expr.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk {
                    result: expr,
                    state,
                })
            }
            pub type Parsed = Vec<Expression>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk {
                result: mut expr,
                state,
            } = part_1::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            Ok(ParseOk {
                result: expr,
                state,
            })
        }
        pub type Parsed = Vec<Expression>;
    }
    #[inline]
    pub(super) fn parse_ParenExpression<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ParenExpression> {
        global.tracer.print_trace_start(&state, "ParenExpression");
        let result = {
            let result = ParenExpression_impl::parse(state, global)?
                .map(|r| super::ParenExpression { expr: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Variable_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Ident(state, &mut *global))
        }
        pub type Parsed = Ident;
    }
    #[inline]
    pub(super) fn parse_Variable<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Variable> {
        global.tracer.print_trace_start(&state, "Variable");
        let result = {
            let result = Variable_impl::parse(state, global)?.map(|r| super::Variable { name: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod FunctionCall_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk {
                result: name,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_Ident(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                .discard_result()?;
            let ParseOk {
                result: args,
                state,
            } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ArgumentList(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                .discard_result()?;
            Ok(ParseOk {
                result: Parsed { name, args },
                state,
            })
        }
        pub struct Parsed {
            pub name: Ident,
            pub args: ArgumentList,
        }
    }
    #[inline]
    pub(super) fn parse_FunctionCall<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, FunctionCall> {
        global.tracer.print_trace_start(&state, "FunctionCall");
        let result = {
            let result = FunctionCall_impl::parse(state, global)?.map(|r| super::FunctionCall {
                name: r.name,
                args: r.args,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ArgumentList_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk {
                            result: mut arg,
                            state,
                        } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_Expression(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: arg, state })
                    }
                    pub type Parsed = Vec<Expression>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut arg: Vec<Expression> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk {
                                result: __result,
                                state: new_state,
                                ..
                            }) => {
                                arg.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: arg, state })
                }
                pub type Parsed = Vec<Expression>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk {
                    result: mut arg,
                    state,
                } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_Expression(state, &mut *global))
                    .map_inner(|result| vec![result])?;
                let ParseOk {
                    result: extend_arg_with,
                    state,
                } = part_1::parse(state, global)?;
                arg.extend(extend_arg_with);
                Ok(ParseOk { result: arg, state })
            }
            pub type Parsed = Vec<Expression>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global))
                .choice(|state| Ok(ParseOk { result: (), state }).map_inner(|_| Vec::new()))
                .end()
        }
        pub type Parsed = Vec<Expression>;
    }
    #[inline]
    pub(super) fn parse_ArgumentList<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ArgumentList> {
        global.tracer.print_trace_start(&state, "ArgumentList");
        let result = {
            let result =
                ArgumentList_impl::parse(state, global)?.map(|r| super::ArgumentList { arg: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Literal_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Integer(state, &mut *global))
                        .map_inner(Some)
                        .map_inner(|r| Parsed {
                            int: r,
                            float: None,
                        })
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Float(state, &mut *global))
                        .map_inner(Some)
                        .map_inner(|r| Parsed {
                            int: None,
                            float: r,
                        })
                })
                .end()
        }
        pub struct Parsed {
            pub int: Option<Integer>,
            pub float: Option<Float>,
        }
    }
    #[inline]
    pub(super) fn parse_Literal<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Literal> {
        global.tracer.print_trace_start(&state, "Literal");
        let result = {
            let result = Literal_impl::parse(state, global)?.map(|r| super::Literal {
                int: r.int,
                float: r.float,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Integer_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_Digit(state, &mut *global))
                    .discard_result()
                {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            if iterations == 0 {
                return Err(state.report_farthest_error());
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Integer<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Integer> {
        global.tracer.print_trace_start(&state, "Integer");
        let result = {
            let result = Integer_impl::parse(state, global)?.map(|r| super::Integer {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Float_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Digit(state, &mut *global))
                        .discard_result()
                    {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                if iterations == 0 {
                    return Err(state.report_farthest_error());
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Digit(state, &mut *global))
                        .discard_result()
                    {
                        Ok(ParseOk {
                            result: __result,
                            state: new_state,
                            ..
                        }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                if iterations == 0 {
                    return Err(state.report_farthest_error());
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = part_0::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '.'))
                .discard_result()?;
            let ParseOk { state, .. } = part_2::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Float<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Float> {
        global.tracer.print_trace_start(&state, "Float");
        let result = {
            let result = Float_impl::parse(state, global)?.map(|r| super::Float {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Digit_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_range(state, '0', '9'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Digit<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Digit> {
        global.tracer.print_trace_start(&state, "Digit");
        let result = {
            let result = Digit_impl::parse(state, global)?.map(|r| super::Digit {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod BinaryOperator_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '+'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '-'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '*'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '/'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '%'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "=="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "!="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '<'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '>'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "<="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, ">="))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "&&"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "||"))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_BinaryOperator<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, BinaryOperator> {
        global.tracer.print_trace_start(&state, "BinaryOperator");
        let result = {
            let result =
                BinaryOperator_impl::parse(state, global)?.map(|r| super::BinaryOperator {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod UnaryOperator_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '+'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '-'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '!'))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '*'))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_UnaryOperator<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, UnaryOperator> {
        global.tracer.print_trace_start(&state, "UnaryOperator");
        let result = {
            let result = UnaryOperator_impl::parse(state, global)?.map(|r| super::UnaryOperator {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Ident_impl {
        use super::*;
        mod closure {
            use super::*;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let mut iterations: usize = 0;
            let mut state = state;
            loop {
                match ChoiceHelper::new(state.clone())
                    .choice(|state| parse_character_range(state, 'a', 'z').discard_result())
                    .choice(|state| parse_character_range(state, 'A', 'Z').discard_result())
                    .choice(|state| parse_character_literal(state, '_').discard_result())
                    .choice(|state| parse_character_range(state, '0', '9').discard_result())
                    .end()
                {
                    Ok(ParseOk {
                        result: __result,
                        state: new_state,
                        ..
                    }) => {
                        state = new_state;
                    }
                    Err(err) => {
                        state = state.record_error(err);
                        break;
                    }
                }
                iterations += 1;
            }
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Ident<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Ident> {
        global.tracer.print_trace_start(&state, "Ident");
        let result = {
            let result =
                Ident_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                    let string = state.slice_until(new_state).to_string();
                    string
                });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
}
